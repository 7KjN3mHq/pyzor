#! /usr/bin/env python

"""A front-end interface to the pyzor daemon."""

import os
import sys
import logging
import optparse
import collections
import ConfigParser

import pyzor
import pyzor.server
import pyzor.engines


def load_configuration():
    """Load the configuration for the server.

    The configuration comes from three sources: the default values, the
    configuration file, and command-line options."""
    # Work out the default directory for configuration files.
    # If $HOME is defined, then use $HOME/.pyzor, otherwise use /etc/pyzor.
    userhome = os.getenv("HOME")
    if userhome:
        homedir = os.path.join(userhome, '.pyzor')
    else:
        homedir = os.path.join("/etc", "pyzor")

    # Configuration defaults.  The configuration file overrides these, and
    # then the command-line options override those.
    defaults = {
        "Port" : "24441",
        "ListenAddress" : "0.0.0.0",
        "Engine" : "gdbm",
        "DigestDB" : "pyzord.db",
        "Threads": "False",
        "MaxThreads": "0",
        "Processes": "False",
        "MaxProcesses": "40",
        "DBConnections": "0",
        "PasswdFile" : "pyzord.passwd",
        "AccessFile" : "pyzord.access",
        "CleanupAge" : str(60 * 60 * 24 * 30 * 4),  # approximately 4 months
        "LogFile" : "pyzord.log",
        "UsageLogFile": "",
    }

    # Process any command line options.
    description = "Listen for and process incoming Pyzor connections."
    opt = optparse.OptionParser(description=description)
    opt.add_option("-n", "--nice", dest="nice", type="int",
                   help="'nice' level", default=0)
    opt.add_option("-d", "--debug", action="store_true", default=False,
                   dest="debug", help="enable debugging output")
    opt.add_option("--homedir", action="store", default=homedir,
                   dest="homedir", help="configuration directory")
    opt.add_option("-a", "--address", action="store", default=None,
                   dest="ListenAddress", help="listen on this IP")
    opt.add_option("-p", "--port", action="store", type="int", default=None,
                   dest="Port", help="listen on this port")
    opt.add_option("-e", "--database-engine", action="store", default=None,
                   dest="Engine", help="select database backend")
    opt.add_option("--dsn", action="store", default=None, dest="DigestDB",
                   help="data source name (filename for gdbm, host,user,"
                   "password,database,table for MySQL)")
    opt.add_option("--threads", action="store", default=None, dest="Threads",
                   help="set to true if multi-threading should be used"
                   " (this may not apply to all engines)")
    opt.add_option("--max-threads", action="store", default=None, type="int",
                   dest="MaxThreads", help="the maximum number of concurrent "
                   "threads (defaults to 0 which is unlimited)")
    opt.add_option("--processes", action="store", default=None,
                   dest="Processes", help="set to true if multi-processing "
                   "should be used (this may not apply to all engines)")
    opt.add_option("--max-processes", action="store", default=None, type="int",
                   dest="MaxProcesses", help="the maximum number of concurrent "
                   "processes (defaults to 40)")
    opt.add_option("--db-connections", action="store", default=None, type="int",
                   dest="DBConnections", help="the number of db connections "
                   "that will be kept by the server. This only applies if "
                   "threads are used. Defaults to 0 which means a new "
                   "connection is used for every thread. (this may not apply "
                   "all engines)")
    opt.add_option("--password-file", action="store", default=None,
                   dest="PasswdFile", help="name of password file")
    opt.add_option("--access-file", action="store", default=None,
                   dest="AccessFile", help="name of ACL file")
    opt.add_option("--cleanup-age", action="store", default=None,
                   dest="CleanupAge",
                   help="time before digests expire (in seconds)")
    opt.add_option("--log-file", action="store", default=None,
                   dest="LogFile", help="name of the log file")
    opt.add_option("--usage-log-file", action="store", default=None,
                   dest="UsageLogFile", help="name of the usage log file")
    opt.add_option("-V", "--version", action="store_true", default=False,
                   dest="version", help="print version and exit")
    options, args = opt.parse_args()

    if options.version:
        print "%s %s" % (sys.argv[0], pyzor.__version__)
        sys.exit(0)

    if len(args):
        opt.print_help()
        sys.exit()
    os.nice(options.nice)

    # Create the configuration directory if it doesn't already exist.
    if not os.path.exists(homedir):
        os.mkdir(homedir)

    # Load the configuration.
    config = ConfigParser.ConfigParser()
    # Set the defaults.
    config.add_section("server")
    for key, value in defaults.iteritems():
        config.set("server", key, value)
    # Override with the configuration.
    config.read(os.path.join(options.homedir, "config"))
    # Override with the command-line options.
    for key in defaults:
        value = getattr(options, key)
        if value is not None:
            config.set("server", key, str(value))
    return config, options


def setup_logging(log_name, filepath, debug):
    """Setup logging according to the specified options. Return the Logger 
    object.
    """
    if debug:
        log_level = logging.DEBUG
        handler = logging.StreamHandler()
    elif not filepath:
        handler = logging.StreamHandler()
        log_level = logging.CRITICAL
    else:
        log_level = logging.INFO
        handler = logging.FileHandler(filepath)

    handler.setLevel(log_level)
    handler.setFormatter(
        logging.Formatter('%(asctime)s %(levelname)s %(message)s'))
    logger = logging.getLogger(log_name)
    logger.setLevel(log_level)
    logger.addHandler(handler)

    return logger


def main():
    """Run the pyzor daemon."""
    # Set umask - this restricts this process from granting any world access
    # to files/directories created by this process.
    os.umask(0077)

    config, options = load_configuration()

    homefiles = ["LogFile", "UsageLogFile", "PasswdFile", "AccessFile"]

    engine = config.get("server", "Engine")
    database_classes = pyzor.engines.database_classes[engine]
    use_threads = config.get("server", "Threads").lower() == "true"
    use_processes = config.get("server", "Processes").lower() == "true"

    if use_threads and use_processes:
        print "You cannot use both processes and threads at the same time"
        sys.exit(1)
    
    # We prefer to use the threaded server, but some database engines
    # cannot handle it.
    if use_threads and database_classes.multi_threaded:
        database_class = database_classes.multi_threaded
    elif use_processes and database_classes.multi_processing:
        database_class = database_classes.multi_processing
    else:
        use_threads = False
        use_processes = False
        database_class = database_classes.single_threaded

    # If the DSN is a filename, then we make it absolute.
    if database_class.absolute_source:
        homefiles.append("DigestDB")

    for filename in homefiles:
        filepath = config.get("server", filename)
        if not filepath:
            continue
        filepath = os.path.expanduser(filepath)
        if not os.path.isabs(filepath):
            filepath = os.path.join(options.homedir, filepath)
        config.set("server", filename, filepath)

    logger = setup_logging("pyzord", config.get("server", "LogFile"),
                           options.debug)
    setup_logging("pyzord-usage", config.get("server", "UsageLogFile"),
                  options.debug)

    # Load passwd_fn and ACL.
    db_file = config.get("server", "DigestDB")
    passwd_fn = config.get("server", "PasswdFile")
    access_fn = config.get("server", "AccessFile")
    address = (config.get("server", "ListenAddress"), 
               int(config.get("server", "port")))
    cleanup_age = int(config.get("server", "CleanupAge"))

    if use_threads:
        max_threads = int(config.get("server", "MaxThreads"))
        bound = int(config.get("server", "DBConnections"))

        database = database_class(db_file, "c", cleanup_age, bound)
        if max_threads == 0:
            logger.info("Starting multi-threaded pyzord server.")
            server = pyzor.server.ThreadingServer(address, database, passwd_fn,
                                                  access_fn)
        else:
            logger.info("Starting bounded (%s) multi-threaded pyzord server.",
                        max_threads)
            server = pyzor.server.BoundedThreadingServer(address, database,
                                                         passwd_fn, access_fn,
                                                         max_threads)
    elif use_processes:
        max_children = int(config.get("server", "MaxProcesses"))
        database = database_class(db_file, "c", cleanup_age)
        logger.info("Starting bounded (%s) multi-processing pyzord server.",
                    max_children)
        server = pyzor.server.ProcessServer(address, database, passwd_fn, access_fn,
                                            max_children)
    else:
        database = database_class(db_file, "c", cleanup_age)
        logger.info("Starting pyzord server.")
        server = pyzor.server.Server(address, database, passwd_fn, access_fn)
    # Start listening.
    server.serve_forever()

if __name__ == "__main__":
    main()
