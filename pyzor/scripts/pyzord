#!/usr/bin/python2

import os
import os.path
import sys
import signal
import getopt
import pyzor
import pyzor.server
import ConfigParser

__author__   = pyzor.__author__
__version__  = pyzor.__version__
__revision__ = "$Id: pyzord,v 1.11 2002-06-17 17:18:08 ftobin Exp $"

default_anonymous_allows = map(pyzor.Opname, ['check', 'report', 'ping'])

def cleanup_server_handler(signum, frame):
    pyzor.server.DBHandle('c').cleanup()


def usage():
    sys.stderr.write("usage: %s [-d] [-c config_file]\n" % sys.argv[0])
    sys.exit(1)


def load_access_file(access_fn, server):
    server.acl = pyzor.server.ACL()
    if os.path.exists(access_fn):
        pyzor.server.AccessFile(open(access_fn)).feed_into(server.acl)
    else:
        output.warn("%s does not exist; using default ACL; allowing anonymous to do %s"
                    % (access_fn, default_anonymous_allows))
        for op in default_anonymous_allows:
            server.acl.add_entry(pyzor.server.ACLEntry((pyzor.anonymous_user,
                                                        op,
                                                        True)))

                                 
def load_passwd_file(access_fn, server):
    server.passwd = pyzor.server.Passwd()
    if os.path.exists(passwd_fn):
        for user, key in pyzor.server.PasswdFile(open(passwd_fn)):
            server.passwd[user] = key


########################################################################
# functions above, run below

debug = 0
(options, args) = getopt.getopt(sys.argv[1:], 'dhc:')
if len(args) != 0:
    usage()

config_fn = None

for (o, v) in options:
    if o == '-d':
        debug = 1
    elif o == '-h':
        usage()
    elif o == '-c':
        config_fn = v

if config_fn is None:
    config_fn = pyzor.Config.get_default_filename()

homedir = pyzor.get_homedir()
# We really shouldn't need to make this unless
# the user wants to use it...
if not os.path.exists(homedir):
    os.mkdir(homedir)

defaults = {'port':          '24441',
            'listenaddress': '0.0.0.0',
            'logfile':       os.path.join(homedir, 'pyzord.log'),
            'pidfile':       os.path.join(homedir, 'pyzord.pid'),
            'digestdb':      os.path.join(homedir, 'pyzord.db'),
            'passwdfile':    os.path.join(homedir, 'pyzord.passwd'),
            'accessfile':    os.path.join(homedir, 'pyzord.access'),
            'CleanupAge':    str(pyzor.server.DBHandle.max_age),
            }

config = pyzor.Config()
config.add_section('server')

for k, v in defaults.items():
    config.set('server', k, v)

config.read(config_fn)


port       = config.getint('server', 'port')
listen_adr = config.get('server', 'ListenAddress')

log_fn    = config.get_filename('server', 'logfile')
pid_fn    = config.get_filename('server', 'pidfile')
dbfile    = config.get_filename('server', 'DigestDB')
passwd_fn = config.get_filename('server', 'passwdfile')
access_fn = config.get_filename('server', 'accessfile')
pyzor.server.DBHandle.max_age = config.getint('server', 'CleanupAge')

output = pyzor.Output(debug=debug)

logfile = open(log_fn, 'a')
pyzor.server.DBHandle.dbfile = dbfile

server = pyzor.server.Server((listen_adr, port),
                             pyzor.server.Log(logfile))


load_passwd_file(passwd_fn, server)
load_access_file(access_fn, server)


if not debug:
    # This step is required so that the new process is guaranteed
    # not to be a process group leader. The next step, setsid(),
    # fails if you're a process group leader.
    pid = os.fork()
    if pid != 0:
        os._exit(0)

    # setsid() to become a process group and session group leader.
    # Since a controlling terminal is associated with a session,
    # and this new session has not yet acquired a controlling
    # terminal our process now has no controlling terminal,
    # which is a Good Thing for daemons.
    os.setsid()
        
    pid = os.fork()
    if pid != 0:
        os._exit(0)

    #sys.stdin.close()
    #sys.stdout.close()
    #sys.stderr.close()

if pid_fn is not None:
    f = open(pid_fn, 'w')
    f.write("%d\n" % os.getpid())
    f.close()

signal.signal(signal.SIGUSR1, cleanup_server_handler)
server.serve_forever()
