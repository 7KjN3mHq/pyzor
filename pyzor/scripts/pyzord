#!/usr/local/bin/python

import os
import os.path
import sys
import signal
import getopt
import pyzor
import pyzor.server
import ConfigParser

__author__   = pyzor.__author__
__version__  = pyzor.__version__
__revision__ = "$Id: pyzord,v 1.6 2002-04-22 00:17:40 ftobin Exp $"

def cleanup_server_handler(signum, frame):
    pyzor.server.DBHandle('c').cleanup()

def usage():
    sys.stderr.write("usage: %s [-d] [-c config_file]\n" % sys.argv[0])
    sys.exit(1)

debug = 0
(options, args) = getopt.getopt(sys.argv[1:], 'dhc:')
if len(args) != 0:
    usage()

config_fn = None

for (o, v) in options:
    if o == '-d':
        debug = 1
    elif o == '-h':
        usage()
    elif o == '-c':
        config_fn = v

if config_fn is None:
    config_fn = pyzor.Config.get_default_filename()

homedir = pyzor.get_homedir()
# We really shouldn't need to make this unless
# the user wants to use it...
if not os.path.exists(homedir):
    os.mkdir(homedir)

defaults = {'port':          '24441',
            'listenaddress': '0.0.0.0',
            'logfile':       os.path.join(homedir, 'pyzord.log'),
            'pidfile':       os.path.join(homedir, 'pyzord.pid'),
            'digestdb':      os.path.join(homedir, 'pyzord.db'),
            'CleanupAge':    str(pyzor.server.DBHandle.max_age),
            }

config = pyzor.Config()
config.add_section('server')

for k, v in defaults.items():
    config.set('server', k, v)

config.read(config_fn)


port       = config.getint('server', 'port')
listen_adr = config.get('server', 'ListenAddress')

log_fn = config.get_filename('server', 'logfile')
pid_fn = config.get_filename('server', 'pidfile')
dbfile = config.get_filename('server', 'DigestDB')
pyzor.server.DBHandle.max_age = config.getint('server', 'CleanupAge')

logfile = open(log_fn, 'a')

pyzor.server.DBHandle.dbfile = dbfile
output = pyzor.Output(debug=debug)

server = pyzor.server.Server((listen_adr, port),
                             pyzor.server.Log(logfile))

if not debug:
    # This step is required so that the new process is guaranteed
    # not to be a process group leader. The next step, setsid(),
    # fails if you're a process group leader.
    pid = os.fork()
    if pid: os._exit(0)

    # setsid() to become a process group and session group leader.
    # Since a controlling terminal is associated with a session,
    # and this new session has not yet acquired a controlling
    # terminal our process now has no controlling terminal,
    # which is a Good Thing for daemons.
    os.setsid()
        
    pid = os.fork()
    if pid: os._exit(0)

    #sys.stdin.close()
    #sys.stdout.close()
    #sys.stderr.close()

if pid_fn is not None:
    f = open(pid_fn, 'w')
    f.write("%d\n" % os.getpid())
    f.close()

signal.signal(signal.SIGUSR1, cleanup_server_handler)
server.serve_forever()
